## 简介
---
介绍一个带加载功能的按钮控件的实现原理，加载动画来自于[CircularProgressDrawable](https://developer.android.google.cn/reference/android/support/v4/widget/CircularProgressDrawable?hl=en)
<br/>
## 效果图（最终效果图在最后面）
---
![](https://upload-images.jianshu.io/upload_images/7565394-4d54f09ac73d0dd0.gif?imageMogr2/auto-orient/strip)
![](https://upload-images.jianshu.io/upload_images/7565394-4f37c5e6d67508c1.gif?imageMogr2/auto-orient/strip)

<br/>

## 下面开始介绍实现的原理
---

![](https://upload-images.jianshu.io/upload_images/7565394-0cd02c573f2a30e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 加载动画
圆环加载就是用setCompoundDrawables放到TextView的drawablewStart中，将文字的Gravity设置Center
```
public class DrawableText extends AppCompatTextView {
  ..... 省略


  private void init(){
        mProgressDrawable = new CircularProgressDrawable(getContext());
        mProgressDrawable.setColorSchemeColors(getTextColors().getDefaultColor());
        mProgressDrawable.setBounds(0, 0, 80, 80);
        setCompoundDrawables(mProgressDrawable, null, null, null);
        mProgressDrawable.setStrokeWidth(10);
    }

    public void start(){
        mProgressDrawable.start();
    }

    public void stop(){
        mProgressDrawable.stop();
    }
}
```

结果效果是这个亚子的：
![](https://upload-images.jianshu.io/upload_images/7565394-fd9d213c563c27b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300)

![](https://upload-images.jianshu.io/upload_images/7565394-def8c86dd0542b09.gif?imageMogr2/auto-orient/strip)

看来实际的效果与我们想象中的不太一样，原来Drawable在一开始我们并没有设置它的位置
```
drawable.setBounds(0, 0, 80, 80)
```
<br/>
<br/>

那么我们应该如何将drawable居中显示文字的旁边？
用一张草图表示大概是这个样子的：
![](https://upload-images.jianshu.io/upload_images/7565394-ac51865a03c7a389.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

中间那部分就是我们想要的位移，通过下面的计算就可以得到所要的位移，
而getWidth()这些参数需要在Layout之后才可以得到，
所以我们干脆在onDraw中对drawable进行位移
```
  //计算需要的位移
    private float calcOffset() {
        //getCompoundPaddingStart()  = paddingStart + drawableWidth + drawablePadding
        return (getWidth() - (getCompoundPaddingStart()  + getTextWidth())) / 2;

    }

    //计算文字的长度
    private float getTextWidth() {
        //在draw时不断计算TextWidth似乎是不合理的，当然目前只是演示用法
        //再者若是多行文字，则测量结果会偏大，但此处不再讨论，有兴趣可以直接去看源码
        return  getPaint().measureText(getText().toString());
    }
```


```

  private void init(){
        mProgressDrawable = new CircularProgressDrawable(getContext());
        mProgressDrawable.setColorSchemeColors(getTextColors().getDefaultColor());
        mProgressDrawable.setBounds(0, 0, 80, 80);
        //先保存Bounds
        bounds = mProgressDrawable.copyBounds();
        setCompoundDrawables(mProgressDrawable, null, null, null);
        mProgressDrawable.setStrokeWidth(10);
    }

 @Override
    protected void onDraw(Canvas canvas) {
        final int offsetX = (int) calcOffsetX();
        mProgressDrawable.setBounds(offsetX, bounds.top, bounds.right + offsetX, bounds.bottom);
        //我们并不能通过offset来直接位移mProgressDrawable，这样为导致动画每次绘制时都会在原来位移过后的基础上再不断向右位移
        //mProgressDrawable.getBounds().offset(offsetX,0);
        super.onDraw(canvas);
    }

```
#### 经过位移的效果
![](https://upload-images.jianshu.io/upload_images/7565394-187ca9d747d23fb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300)


似乎看起来还是有一点点别扭，从效果上看出文字和drawable是一起居中的，
看了一下TextView的源码发现setCompoundDrawables后会先划分出TextView左侧及右侧drawable需要的空间，
然后再按照剩余的空间来居中显示，
所以最后得到通过位移得到的效果是文字和drawable一起居中显示的。

为了让文字在整个布局的中间，我们可以通过平移画布来实现文字的居中效果
```

 @Override
    protected void onDraw(Canvas canvas) {
        final int offsetX = (int) calcOffsetX();
        mProgressDrawable.setBounds(offsetX, bounds.top, bounds.right + offsetX, bounds.bottom);
        //我们并不能通过offset来直接位移mProgressDrawable，这样为导致动画每次绘制时都会不断向右位移
        //mProgressDrawable.getBounds().offset(offsetX,0);

        //计算画布向左平移的距离
        final int tranX = (bounds.width() + getCompoundDrawablePadding()) / 2;
        canvas.translate(-tranX, 0);

        super.onDraw(canvas);
    }

```
#### 我们可以看到，文字也居中了
![](https://upload-images.jianshu.io/upload_images/7565394-75cd27932e9cda81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/150)


#### 最后再说一下收缩效果的实现方式
主要也是通过 getLayoutParams().width和 getLayoutParams().height来改变布局的尺寸，
在开始收缩时先将文本设置为空字符、drawablePadding设为0，然后再开始收缩动画，具体的方式可以自行尝试
```
        mShrinkAnimator = ValueAnimator.ofFloat(0, 1f);
        mShrinkAnimator.setDuration(mShrinkDuration);
        mShrinkAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                // mRootViewSizeSaved是预先保存原先的尺寸，getShrinkSize() 是缩放后的尺寸
                // b = getRootViewSize()
                // k = getRootViewSize() - getLoadingSize
                getLayoutParams().width = (int) ((getShrinkSize() - mRootViewSizeSaved[0]) * (float) animation.getAnimatedValue() + mRootViewSizeSaved[0]);
                getLayoutParams().height = (int) ((getShrinkSize() - mRootViewSizeSaved[1]) * (float) animation.getAnimatedValue() + mRootViewSizeSaved[1]);
                requestLayout();
            }
        });
```
<br/><br/>

# 结语
---
本文介绍了带加载效果的按钮实现整体思路，然鹅如果想要真正使用并没有文中介绍的那么简单，还需要考虑各种细节和因素。(头发又变少了呢~)
最后可以看下完整实现的效果，已经上传到github上了([LoadingButton](https://github.com/FlodCoding/LoadingButton))，加了一些功能（本来只是想简单实现一个按钮旁边有一个Loading，结果功能越写越多就变成这样，苦笑~）
有兴趣朋友可以给个星星，提提issue喝喝茶，我是新来的第一次写这种文章请多多包涵呀。

![](https://upload-images.jianshu.io/upload_images/7565394-3ae40e74968373b6.gif?imageMogr2/auto-orient/strip)
![](https://upload-images.jianshu.io/upload_images/7565394-70294e35ea498122.gif?imageMogr2/auto-orient/strip)





